myButLast :: [a] -> a                           // getting the second element from the end of an array

myButLast [] = error "Empty list"
myButLast [x] = error "Too few elements"
myButLast (x:xs) = 
		if length xs == 1 then x
		else myButLast xs

main = print  $ myButLast [1,2,3,4]     

------------------------------------------------------------------------------------------------------------------------------

elementAt :: ([a],Int) -> a                   // getting the given element of an array recursively

elementAt ([],a1) = error "no list exists"
elementAt (xs2,0) = error "invalid index"
elementAt ((x:xs),a2)
        | a2==1 = x 
        | a2 > length xs+1 = error "index out of array range"
		| otherwise =  elementAt $ (xs,a2-1)

main = print  $ elementAt ([1,2,3],2)

------------------------------------------------------------------------------------------------------------------------------

myLength :: [a] -> Int                  // getting the length of an array recursively

myLength [] = 0
myLength [x] = 1
myLength (x:xs) = 1 +  myLength xs

main = print  $ myLength [1,2,3,4,5]

------------------------------------------------------------------------------------------------------------------------------

myReverse :: [a] -> [a]                 // reversing an array recursively

myReverse [] = []
myReverse [x] = [x]
myReverse (x:xs) = myReverse xs ++ [x] 

main = print  $ myReverse [1,2,3,4,5]

------------------------------------------------------------------------------------------------------------------------------

isPalindrome :: (Eq a) => [a] -> Bool                  // detecting palindrome array 
isPalindrome xs = xs == (reverse xs)

isPalindrome []  = True
isPalindrome [x] = False
isPalindrome list  = (head list) == (last list) && (isPalindrome $ init $ tail list)
main = print $ isPalindrome [1,2,3,2,1]

------------------------------------------------------------------------------------------------------------------------------

data NestedList a = Elem a | List [NestedList a]  // since nested lists are type error in Haskell, we need to define it

flatten :: NestedList a -> [a]                   // flattens a nested list

flatten (List [])     = []
flatten (Elem temp)   = [temp]
flatten (List (x:xs)) = flatten x ++ flatten (List xs)

main = print $ flatten $ List[Elem 1, List [Elem 2, Elem 3], Elem 4]

------------------------------------------------------------------------------------------------------------------------------

removeDuplicates :: Eq a => [a] -> [a]            // removes duplicate values of a list
removeDuplicates = helper []
    where helper seen [] = seen
          helper seen (x:xs)
              | x `elem` seen = helper seen xs
              | otherwise = helper (seen ++ [x]) xs

main = print $ removeDuplicates [1,2,2,3,5,5]

------------------------------------------------------------------------------------------------------------------------------

repli :: [a] -> Int -> [a]               // replicates elements of a list given times

repli xs n = concatMap (replicate n) xs
main = print $ repli [1,2,3] 2

------------------------------------------------------------------------------------------------------------------------------

dropEvery :: [a] -> Int -> [a]            // drops each Nth element of a list recursively

dropEvery xs 0 = []
dropEvery xs n = helper xs n
    where helper [] _ = []
          helper (x:xs) 1 = helper xs n
          helper (x:xs) k = x : helper xs (k-1)
	  
main = print $ dropEvery [1,2,3,4,5,6,7,8] 3

------------------------------------------------------------------------------------------------------------------------------
removeAt :: Int -> [a] -> (a, [a])           // removes Nth element of a list and returns it together with the remaining list

removeAt 1 (x:xs) = (x, xs)
removeAt n (x:xs) = (l, x:r)
	where (l, r) = removeAt (n - 1) xs
	  
main = print $ removeAt 2 [1,2,3]

------------------------------------------------------------------------------------------------------------------------------

data MyList = E | L (Int, MyList) deriving Show  	 // recursive list definition and its use
ex1= L (1, L(2, L(3, E)))
first_el (x:y) = x
first_el2 (L (x,y)) = x

ex2= [1,2,3,4,5,6,7]
last_el (x:[]) = x
last_el (x:xs) = last_el xs

last_el2 (L (x,E)) = x
last_el2 (L (x,xs)) = last_el2 xs
main = do 
    print $ last_el ex2
    print $ last_el2 ex1

------------------------------------------------------------------------------------------------------------------------------

data BT a = Empty | Node (a, BT a, BT a) deriving Show      // recursive tree implementation and sum of the nodes
bt= Node(1, Node(2,Empty,Empty),Node(3,Node(4,Empty,Empty),Empty))
sum_bt Empty = 0
sum_bt (Node (x,y,z)) = x + sum_bt y + sum_bt z

main = print $ sum_bt bt

------------------------------------------------------------------------------------------------------------------------------
data EGG = Egg CHICKEN | Eg Int      			// recursive type declarations and function implementations
data CHICKEN = Chicken EGG | Chick Bool
egg = Egg (Chicken (Egg (Chicken (Egg (Chick True)))))
chicken= Chicken (Egg (Chicken (Eg 2)))
f(Eg x) = x
f (Egg y)= 2*(g y)

g(Chick True) =1
g(Chick False) =0
g(Chicken x) =1+ (f x)
main = print $ g chicken

------------------------------------------------------------------------------------------------------------------------------


